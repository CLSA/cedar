{##
 # test_entry_classfication_transcribe.twig
 # 
 # Transcribe a classification type test.
 # @author Dean Inglis <inglisd@mcmaster.ca>
 # @see base_view.twig for parameters
 #}
{% extends "widget.twig" %}

{% block javascript %}

  {{ parent() }}

  <script type="text/javascript">
  
    function configure_ui() {
      // disable elements based on deferred status
      if( {{ deferred }} ) {
        $( "#{{ parent.full }}__audio_fault" ).prop( "disabled", true );
        $( "#{{ parent.full }}_Defer" ).button( { "disabled": true } );
        $( "#{{ parent.full }}_Reset" ).button( { "disabled": true } );
        $( "#{{ widget.full }}_Add" ).button( { "disabled": true } );
        $( "#{{ widget.full }}__entry_table" ).find( "input:text" ).each( function() {
          $(this).prop( "disabled", true );
        } );
      } else {
        // count the number of inputs, how many have text in them and which is the last
        // non-disabled entry
        var numFilled = 0;
        var numInput = 0;
        var lastEmpty = null;

        $( 'input:text' ).each( function() {
          if( 0 < $(this).val().length ) {
            numFilled++;
          } else {
            if( !$(this).prop( "disabled" ) ) lastEmpty = $(this);
          }            
          numInput++;
        } );

        console.log( [ numFilled, numInput, lastEmpty ] );

        // only enable the next button when there is at least one entry filled
        $( "#{{ parent.full }}_Next" ).prop( "disabled", 0 == numFilled );

        // only enable the add button when all inputs are filled
        $( "#{{ widget.full }}_Add" ).button( { "disabled": numFilled != numInput } );
        
        if( null !== lastEmpty ) lastEmpty.focus();
      }
    }

    // overrides the default autocomplete filter function to search only from the beginning
    // of the string
/*
    $.ui.autocomplete.filter = function ( array, term ) {
      var matcher = new RegExp( "^" + $.ui.autocomplete.escapeRegex( term ), "i" );
      return $.grep( array, function ( value ) {
        return matcher.test( value.label || value.value || value );
      } );
    };

    function get_text_complete() {
      var args = new Object();
      args["dictionary_id"] = "{{ dictionary_id }}";
      if( undefined != "{{ intrusion_dictionary_id }}" ) {
        args["intrusion_dictionary_id"] = "{{ intrusion_dictionary_id }}";
      }
      args["language"] = "{{ language }}";
      args["words_only"] = 1;
      return ajax_pull( "word", "list", args );
    }
*/

    function update_input_list() {
      $input_list = $( "#{{ widget.full }}__entry_table" ).find( "input:text" );

/*
      // set up the autocomplete on all text inputs
      $input_list.autocomplete( {
        source: get_text_complete(),
        minLength: 1,
        select: function( event, ui ) {
          $(this).val( ui.item.value );
          // TODO see if latest version of jquery has double enter key bug fixed
          //$(this).trigger( 'change' );
        }
      } );
*/

      // callback for when text inputs are changed
      $input_list.change( function() {
        var args = new Object();
        var columns = new Object();
        args.id = $(this).prop( "id" ).split( "__" )[0];
        columns["rank"] = parseInt( $(this).prop( "id" ).split( "__" )[1] );
        columns["test_entry_id"] = {{ parent.id }};
        columns["word_id"] = "";
        var candidate = $(this).val().trim().toLowerCase();
        if( 0 == candidate.length ) {
          alert( "Blank entries are not permitted" );
          return false;
        }
        columns["word_candidate"] = candidate;
        args.columns = columns;

        if( ajax_push( "{{ widget.subject }}", "edit", args ) ) {
          // we've trimmed and lower-cased the candidate, so update the UI
          $(this).val( candidate );

          // now determine what type of word this is
          args.id = {{ test_id }};
          args["language"] = "{{ language }}";
          args["word_candidate"] = candidate;
          var classification = ajax_pull( "test", "classify_word", args );
          if( undefined != classification ) {
            $(this).removeClass( "candidate intrusion variant primary" );
            $(this).addClass( classification );
          }

          // now enable the next input
          var next_rank_id = "__" + ( columns["rank"] + 1 );
          $( 'input:text[id$="' + next_rank_id + '"]' ).prop( "disabled", false );

          configure_ui();
        }
      } );// end text input change
    }

    $( function () {

      update_input_list();
      configure_ui();

      $( "#{{ widget.full }}_Add" ).button( {
        text: false,
        icons: { primary: "ui-icon-plusthick" }
        } )
      .click( function() {
        var html = '<td class="added"><input type="text"></td>';
        var maxTd = $( "#{{ widget.full }}__entry_table tr:first td" ).length;
        var targetRow = $( "#{{ widget.full }}__entry_table tr" ).length - 1;
        var numTd = $( "#{{ widget.full }}__entry_table tr:nth-child(" + targetRow + ") td" ).length;
        if( numTd === maxTd ) {
          html = '<tr class="added">' + html + "</tr>";
          $( "#{{ widget.full }}__entry_table tr:last" ).before( html );
        } else {
          $( "#{{ widget.full }}__entry_table tr:last" ).prev().append( html );
        }
        var args = new Object();
        var columns =  new Object();
        columns["test_entry_id"] = {{ parent.id }};          
        //TODO fix this rank bug ... needs to be set!!!
        columns["rank"] = "";
        args.columns = columns;
        if( ajax_push( "{{ widget.subject }}", "new", args ) ) {
          update_input_list();
          $( "#{{ widget.full }}_Add" ).button( { "disabled": true } );
          $( "#{{ widget.full }}__entry_table tr:last" ).prev().find( 'input:last' ).focus();
        }                          
      } ); // end Add button click

      $( "#{{ parent.full }}_Reset" ).click( function() {
        if( ajax_push( "{{ parent.subject }}", "reset", { "id": {{ parent.id }} } ) ) {
          $( 'input:text' ).each( function() {
            $(this).removeClass( "candidate intrusion variant primary" );
            var rank = parseInt( $(this).prop( "id" ).split("__")[1] );

            // note that the present state of the value is set here
            // and attr( "value" ) will retain the original value
            $(this).val( "" );

            $(this).prop( "disabled", rank !== 1 );
          } );
          $( "td.added" ).remove();
          $( "tr.added" ).remove();

          configure_ui();
        }
      } );// end Reset button click
    } );
  </script>

{% endblock javascript %}

{% block widget %}

  <div class="spacer">

  <table id="{{ widget.full }}__entry_table">

    <tbody>

    {% set numcell = 4 %}
    {% set kprev= 'true' %}
    {% set imax = entry_data|length-1 %}
    {% if numcell > imax %}
      {% set numcell = imax %}
    {% endif %}  
    
    {% for i in range(0, imax, numcell) %}

      <tr>

      {% set kmax = i+numcell-1 %}
      {% if kmax > imax %}
        {% set kmax = imax %}
      {% endif %}  
      {% for k in i..kmax %}

        {% set value = '' %}
        {% if entry_data[k].word_id is defined %}
          {% set value = entry_data[k].word %}
        {% elseif entry_data[k].word_candidate is defined %}  
            {% set value = entry_data[k].word_candidate %}
        {% endif %}
        {% set status = entry_data[k].word_id ? "word" : 
                        entry_data[k].word_candidate ? "candidate" : "empty" %} 

        <td>
          <input type="text"
           id="{{ entry_data[ k ].id }}__{{ entry_data[ k ].rank }}"
           {% if entry_data[k].classification is defined %}
             class="{{ entry_data[k].classification }}"
           {% endif %}  
           
           {% if editable == false %}
             { readonly }
           {% endif %}

           {% if status == 'empty'  %} 
             {% if kprev == 'false' %}
               { disabled }
             {% endif %}
             {% set kprev = 'false' %}
           {% elseif status == 'candidate' %}
               {% set kprev = 'true' %}
           {% elseif status == 'word' %}
               {% set kprev = 'true' %}
           {% endif %}
           
           value="{{ value }}">
        </td>

      {% endfor %}

      </tr>

    {% endfor %}

      <tr>
        <td colspan="{{ numcell }}">
            <button class="{{ widget.full }}__add_entry"
              style="float:right"
              id="{{ widget.full }}_Add">Add</button>
         </td>     
      </tr>

    </tbody>
  </table>

{% endblock widget %}

